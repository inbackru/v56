# Резервная копия базы данных InBack

## Информация о бекапе

**Дата создания:** 05.10.2025
**СУБД:** PostgreSQL 16 (Neon)
**Размер SQL дампа:** 2.6 MB (16,783 строк)
**Размер Custom дампа:** 872 KB (сжатый формат)

## Содержимое базы данных

База данных содержит следующие таблицы:
- `users` - пользователи системы
- `properties` - объекты недвижимости
- `residential_complexes` - жилые комплексы
- `applications` - заявки от клиентов
- `favorites` - избранные объекты пользователей
- `blog_posts` - статьи блога
- `districts` - районы города с геометрией (53 района)
- `streets` - улицы города с координатами (1,587 улиц)
- `it_companies` - реестр ИТ-компаний для проверки (9,085 компаний)
- `cashback_rates` - ставки кэшбэка по ЖК

## Файлы бекапа

### 1. `inback_backup_YYYYMMDD_HHMMSS.sql`
**Формат:** Plain SQL
**Использование:** Простое восстановление через psql

**Преимущества:**
- Читаемый текстовый формат
- Можно редактировать вручную
- Подходит для выборочного восстановления

**Недостатки:**
- Больший размер файла
- Медленнее восстанавливается

### 2. `inback_backup_YYYYMMDD_HHMMSS.dump`
**Формат:** PostgreSQL Custom Format
**Использование:** Гибкое восстановление через pg_restore

**Преимущества:**
- Сжатый формат (в 3 раза меньше)
- Быстрое восстановление
- Выборочное восстановление таблиц
- Параллельное восстановление

**Недостатки:**
- Не читается человеком
- Требует pg_restore

---

## Инструкция по восстановлению

### Способ 1: Восстановление из SQL файла (простой)

#### Шаг 1: Подготовка
```bash
# Убедитесь, что у вас есть DATABASE_URL
echo $DATABASE_URL
```

#### Шаг 2: Создание новой базы данных (опционально)
Если вы хотите восстановить в новую базу данных:
```bash
# Создайте новую базу через Replit Database UI
# или используйте существующую базу
```

#### Шаг 3: Очистка существующей базы (если нужно)
```bash
# ВНИМАНИЕ: Это удалит все существующие данные!
dropdb --if-exists $DATABASE_URL
createdb $DATABASE_URL
```

#### Шаг 4: Восстановление
```bash
psql "$DATABASE_URL" < inback_backup_20251005_141237.sql
```

#### Шаг 5: Проверка
```bash
psql "$DATABASE_URL" -c "\dt"  # Список таблиц
psql "$DATABASE_URL" -c "SELECT COUNT(*) FROM properties;"
psql "$DATABASE_URL" -c "SELECT COUNT(*) FROM it_companies;"
```

---

### Способ 2: Восстановление из Custom формата (рекомендуется)

#### Шаг 1: Полное восстановление
```bash
# Восстановление всей базы
pg_restore -d "$DATABASE_URL" --clean --if-exists inback_backup_20251005_141256.dump
```

#### Шаг 2: Восстановление с параллелизмом (быстрее)
```bash
# Используем 4 параллельных процесса
pg_restore -d "$DATABASE_URL" --clean --if-exists --jobs=4 inback_backup_20251005_141256.dump
```

#### Шаг 3: Выборочное восстановление таблиц
```bash
# Восстановить только таблицу it_companies
pg_restore -d "$DATABASE_URL" --clean --if-exists -t it_companies inback_backup_20251005_141256.dump

# Восстановить несколько таблиц
pg_restore -d "$DATABASE_URL" --clean --if-exists -t properties -t residential_complexes inback_backup_20251005_141256.dump
```

#### Шаг 4: Восстановление только данных (без схемы)
```bash
pg_restore -d "$DATABASE_URL" --data-only inback_backup_20251005_141256.dump
```

#### Шаг 5: Восстановление только схемы (без данных)
```bash
pg_restore -d "$DATABASE_URL" --schema-only inback_backup_20251005_141256.dump
```

---

### Способ 3: Быстрое восстановление через скрипт

Используйте готовый скрипт:

```bash
# Полное восстановление (осторожно - удалит существующие данные!)
bash restore_full.sh

# Восстановление только данных
bash restore_data_only.sh
```

---

## Автоматическое восстановление

### restore_full.sh
Скрипт для полного восстановления базы данных с подтверждением.

### restore_data_only.sh
Скрипт для восстановления только данных в существующую схему.

---

## Проверка восстановленной базы

После восстановления выполните следующие проверки:

```bash
# 1. Проверка всех таблиц
psql "$DATABASE_URL" -c "\dt"

# 2. Подсчет записей в основных таблицах
psql "$DATABASE_URL" -c "
SELECT 
    'properties' as table_name, COUNT(*) as count FROM properties
UNION ALL
SELECT 'residential_complexes', COUNT(*) FROM residential_complexes
UNION ALL
SELECT 'applications', COUNT(*) FROM applications
UNION ALL
SELECT 'it_companies', COUNT(*) FROM it_companies
UNION ALL
SELECT 'districts', COUNT(*) FROM districts
UNION ALL
SELECT 'streets', COUNT(*) FROM streets;
"

# 3. Проверка индексов
psql "$DATABASE_URL" -c "\di"

# 4. Проверка внешних ключей
psql "$DATABASE_URL" -c "
SELECT
    tc.table_name, 
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name 
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY';
"
```

---

## Восстановление в production базу

**ВНИМАНИЕ:** Replit Agent может работать только с development базой данных.

Для восстановления в production базу:

1. Перейдите в Database панель Replit
2. Переключитесь на Production базу
3. Скачайте файл бекапа на локальный компьютер
4. Используйте DATABASE_URL production базы для восстановления

```bash
# Пример с production DATABASE_URL
export PRODUCTION_DB_URL="postgres://user:pass@host:5432/dbname"
psql "$PRODUCTION_DB_URL" < inback_backup_20251005_141237.sql
```

---

## Создание нового бекапа

Для создания свежего бекапа выполните:

```bash
# SQL формат
pg_dump "$DATABASE_URL" > database_backup/inback_backup_$(date +%Y%m%d_%H%M%S).sql

# Custom формат (рекомендуется)
pg_dump -Fc "$DATABASE_URL" > database_backup/inback_backup_$(date +%Y%m%d_%H%M%S).dump
```

---

## Частые проблемы и решения

### Проблема: "relation already exists"
**Решение:** Используйте флаг `--clean --if-exists` при восстановлении
```bash
pg_restore -d "$DATABASE_URL" --clean --if-exists inback_backup_20251005_141256.dump
```

### Проблема: "permission denied"
**Решение:** Убедитесь, что у вас есть права администратора на базу данных

### Проблема: "out of memory"
**Решение:** Используйте параллельное восстановление с меньшим числом процессов
```bash
pg_restore -d "$DATABASE_URL" --clean --if-exists --jobs=2 inback_backup_20251005_141256.dump
```

### Проблема: Конфликт данных при восстановлении
**Решение:** Очистите базу перед восстановлением
```bash
# Удалите все таблицы
psql "$DATABASE_URL" -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
# Затем восстановите
pg_restore -d "$DATABASE_URL" inback_backup_20251005_141256.dump
```

---

## Контрольные суммы файлов

Для проверки целостности файлов:

```bash
# Создать контрольные суммы
sha256sum *.sql *.dump > checksums.txt

# Проверить контрольные суммы
sha256sum -c checksums.txt
```

---

## Дополнительная информация

### Структура данных
- **Объекты недвижимости:** ~5,000+ записей
- **ИТ-компании:** 9,085 записей (актуально на 01.10.2025)
- **Районы с геометрией:** 53 района
- **Улицы с координатами:** 1,587 улиц
- **Жилые комплексы:** ~300+ комплексов

### Важные индексы
- `it_companies.inn` - индекс для быстрого поиска по ИНН
- `it_companies.name` - индекс для быстрого поиска по названию
- `properties.district_id` - связь с районами
- `properties.residential_complex_id` - связь с ЖК

### Зависимости
База данных использует следующие расширения PostgreSQL:
- `uuid-ossp` - для генерации UUID (если используется)

---

## Поддержка

При возникновении проблем с восстановлением:
1. Проверьте версию PostgreSQL: `psql --version`
2. Проверьте доступность DATABASE_URL: `echo $DATABASE_URL`
3. Проверьте логи восстановления на наличие ошибок
4. Убедитесь, что файл бекапа не поврежден

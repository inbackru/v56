try { await loadComparisonFromStorage(); updateStats(); console.log('‚úÖ Comparison initialization completed'); } catch (error) { console.error('‚ùå Error during initialization:', error); } }); function switchTab(tab) { currentTab = tab; // Update tab buttons const propertiesTab = document.getElementById('properties-tab'); const complexesTab = document.getElementById('complexes-tab'); if (tab === 'properties') { propertiesTab.className = 'px-6 py-3 text-sm font-medium text-white bg-[#0088CC] rounded-l-lg'; complexesTab.className = 'px-6 py-3 text-sm font-medium text-gray-700 bg-gray-100 rounded-r-lg hover:bg-gray-200'; renderComparison(); } else { propertiesTab.className = 'px-6 py-3 text-sm font-medium text-gray-700 bg-gray-100 rounded-l-lg hover:bg-gray-200'; complexesTab.className = 'px-6 py-3 text-sm font-medium text-white bg-[#0088CC] rounded-r-lg'; renderComplexComparison(); } } async function loadComplexComparisonFromStorage() { // Read complex IDs from localStorage const complexIds = JSON.parse(localStorage.getItem('comparison_complexes') || '[]'); if (complexIds.length === 0) { complexComparisonData = []; return; } try { // Load complex data from API const response = await fetch('/api/manager/complexes/favorites/list', { method: 'GET', credentials: 'same-origin', headers: { 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error('Failed to load complexes'); } const data = await response.json(); const allComplexes = data.complexes || []; // Filter complexes based on comparison IDs - API returns 'id' field, not 'complex_id' complexComparisonData = allComplexes.filter(complex => complexIds.includes(String(complex.id)) ); console.log('üè¢ Complex comparison loaded:', { complexIds: complexIds, allComplexes_count: allComplexes.length, filtered_count: complexComparisonData.length, first_complex_schema: allComplexes[0] || null }); } catch (error) { console.error('Error loading complex comparison data:', error); complexComparisonData = []; } } async function loadComparisonFromStorage() { // Read comparison data directly from localStorage (–∫–∞–∫ –±—ã–ª–æ —Ä–∞–Ω—å—à–µ) const storedComparisons = localStorage.getItem('comparisons'); const storedComplexes = localStorage.getItem('comparison_complexes'); console.log('üîç Loading from localStorage:', { comparisons: storedComparisons, complexes: storedComplexes }); // Load property comparison data if (storedComparisons) { try { const parsed = JSON.parse(storedComparisons); if (Array.isArray(parsed) && parsed.length > 0) { // If it's array of IDs, we need to load property data if (typeof parsed[0] === 'string' || typeof parsed[0] === 'number') { console.log('üìã Found property IDs, loading from API...'); await loadPropertiesByIds(parsed); } else { // If it's array of objects, use directly console.log('üìã Found property objects, using directly'); comparisonData = parsed.slice(0, 4); } } } catch (error) { console.error('Error parsing comparisons:', error); comparisonData = []; } } else { comparisonData = []; } // Load complex comparison data if (storedComplexes) { try { const parsed = JSON.parse(storedComplexes); if (Array.isArray(parsed) && parsed.length > 0) { // If it's array of IDs, we need to load complex data if (typeof parsed[0] === 'string' || typeof parsed[0] === 'number') { console.log('üìã Found complex IDs, loading from API...'); await loadComplexesByIds(parsed); } else { // If it's array of objects, use directly console.log('üìã Found complex objects, using directly'); complexComparisonData = parsed.slice(0, 4); } } } catch (error) { console.error('Error parsing complex comparisons:', error); complexComparisonData = []; } } else { complexComparisonData = []; } renderComparison(); } async function loadPropertiesByIds(propertyIds) { try { const idsParam = propertyIds.join(','); const response = await fetch(`/api/manager/favorites-properties?ids=${idsParam}`); if (response.ok) { const data = await response.json(); comparisonData = data.properties || []; console.log('‚úÖ Loaded', comparisonData.length, 'properties from API'); } else { console.error('Failed to load properties from API'); comparisonData = []; } } catch (error) { console.error('Error loading properties:', error); comparisonData = []; } } async function loadComplexesByIds(complexIds) { try { const response = await fetch('/api/manager/complexes/favorites/list'); if (response.ok) { const data = await response.json(); const allComplexes = data.complexes || []; // Filter complexes by IDs complexComparisonData = allComplexes.filter(complex => complexIds.includes(String(complex.id)) ).slice(0, 4); console.log('‚úÖ Loaded', complexComparisonData.length, 'complexes from API'); } else { console.error('Failed to load complexes from API'); complexComparisonData = []; } } catch (error) { console.error('Error loading complexes:', error); complexComparisonData = []; } } function saveComparisonToStorage() { // Update the main comparison localStorage with current property IDs const propertyIds = comparisonData.map(p => String(p.property_id)); localStorage.setItem('comparisons', JSON.stringify(propertyIds)); } function addToComparison(property) { if (comparisonData.length >= maxComparisons) { alert(`–ú–∞–∫—Å–∏–º—É–º ${maxComparisons} –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è`); return; } // Check if property already exists const exists = comparisonData.some(p => p.property_id === property.property_id); if (exists) { alert('–û–±—ä–µ–∫—Ç —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ'); return; } comparisonData.push(property); saveComparisonToStorage(); renderComparison(); updateStats(); } function removeFromComparison(propertyId) { comparisonData = comparisonData.filter(p => p.property_id !== propertyId); saveComparisonToStorage(); renderComparison(); updateStats(); } function clearComparison() { if (currentTab === 'properties') { comparisonData = []; localStorage.setItem('comparisons', JSON.stringify([])); renderComparison(); } else { complexComparisonData = []; localStorage.setItem('comparison_complexes', JSON.stringify([])); renderComplexComparison(); } updateStats(); } function renderComplexComparison() { const emptyDiv = document.getElementById('empty-comparison'); const tableDiv = document.getElementById('comparison-table'); const tbody = document.getElementById('comparison-body'); if (complexComparisonData.length === 0) { emptyDiv.classList.remove('hidden'); tableDiv.classList.add('hidden'); return; } emptyDiv.classList.add('hidden'); tableDiv.classList.remove('hidden'); // Clear existing content tbody.innerHTML = ''; // Add complex images row const imageRow = createTableRow('–§–æ—Ç–æ'); complexComparisonData.forEach((complex, index) => { const cell = imageRow.children[index + 1]; if (complex.complex_image) { cell.innerHTML = `
${complex.complex_name}–£–¥–∞–ª–∏—Ç—å
`; } }); tbody.appendChild(imageRow); // Add complex details rows const complexRows = [ { key: 'complex_name', label: '–ù–∞–∑–≤–∞–Ω–∏–µ –ñ–ö', className: 'font-semibold' }, { key: 'developer_name', label: '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫' }, { key: 'complex_address', label: '–ê–¥—Ä–µ—Å' }, { key: 'district', label: '–†–∞–π–æ–Ω' }, { key: 'min_price', label: '–¶–µ–Ω–∞ –æ—Ç', formatter: formatPrice, className: 'text-lg font-bold text-[#0088CC]' }, { key: 'max_price', label: '–¶–µ–Ω–∞ –¥–æ', formatter: formatPrice }, { key: 'buildings_count', label: '–ö–æ—Ä–ø—É—Å–æ–≤' }, { key: 'apartments_count', label: '–ö–≤–∞—Ä—Ç–∏—Ä' }, { key: 'delivery_date', label: '–°–¥–∞—á–∞' }, { key: 'status', label: '–°—Ç–∞—Ç—É—Å' }, { key: 'cashback_rate', label: '–ö—ç—à–±—ç–∫', formatter: (val) => val ? `${val}%` : '-' } ]; complexRows.forEach(rowData => { const row = createTableRow(rowData.label); complexComparisonData.forEach((complex, index) => { const cell = row.children[index + 1]; let value = complex[rowData.key] || '-'; if (rowData.formatter && complex[rowData.key]) { value = rowData.formatter(complex[rowData.key]); } cell.innerHTML = `${value}`; }); tbody.appendChild(row); }); // Update last updated time document.getElementById('last-updated').textContent = new Date().toLocaleTimeString('ru-RU'); } function removeFromComplexComparison(complexId) { complexComparisonData = complexComparisonData.filter(c => c.complex_id !== complexId); const complexIds = complexComparisonData.map(c => String(c.complex_id)); localStorage.setItem('comparison_complexes', JSON.stringify(complexIds)); renderComplexComparison(); updateStats(); } function renderComparison() { const emptyDiv = document.getElementById('empty-comparison'); const tableDiv = document.getElementById('comparison-table'); const tbody = document.getElementById('comparison-body'); if (comparisonData.length === 0) { emptyDiv.classList.remove('hidden'); tableDiv.classList.add('hidden'); return; } emptyDiv.classList.add('hidden'); tableDiv.classList.remove('hidden'); // Clear existing content tbody.innerHTML = ''; // Add property images row const imageRow = createTableRow('–§–æ—Ç–æ'); comparisonData.forEach((property, index) => { const cell = imageRow.children[index + 1]; if (property.property_image) { cell.innerHTML = `
${property.property_name}–£–¥–∞–ª–∏—Ç—å
`; } }); tbody.appendChild(imageRow); // Add property details rows const rows = [ { key: 'property_name', label: '–ù–∞–∑–≤–∞–Ω–∏–µ', className: 'font-semibold' }, { key: 'property_price', label: '–¶–µ–Ω–∞', formatter: formatPrice, className: 'text-lg font-bold text-[#0088CC]' }, { key: 'property_type', label: '–¢–∏–ø' }, { key: 'rooms', label: '–ö–æ–º–Ω–∞—Ç' }, { key: 'property_size', label: '–û–±—â–∞—è –ø–ª–æ—â–∞–¥—å', formatter: (val) => val ? `${val} –º¬≤` : '-' }, { key: 'living_area', label: '–ñ–∏–ª–∞—è –ø–ª–æ—â–∞–¥—å', formatter: (val) => val ? `${val} –º¬≤` : '-' }, { key: 'kitchen_area', label: '–ü–ª–æ—â–∞–¥—å –∫—É—Ö–Ω–∏', formatter: (val) => val ? `${val} –º¬≤` : '-' }, { key: 'price_per_sqm', label: '–¶–µ–Ω–∞ –∑–∞ –º¬≤', formatter: formatPrice }, { key: 'complex_name', label: '–ñ–ö' }, { key: 'developer_name', label: '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫' }, { key: 'district', label: '–†–∞–π–æ–Ω' }, { key: 'floor', label: '–≠—Ç–∞–∂' }, { key: 'total_floors', label: '–≠—Ç–∞–∂–Ω–æ—Å—Ç—å' }, { key: 'condition', label: '–°–æ—Å—Ç–æ—è–Ω–∏–µ' }, { key: 'ceiling_height', label: '–í—ã—Å–æ—Ç–∞ –ø–æ—Ç–æ–ª–∫–æ–≤' }, { key: 'furniture', label: '–ú–µ–±–µ–ª—å' }, { key: 'balcony', label: '–ë–∞–ª–∫–æ–Ω/–õ–æ–¥–∂–∏—è' }, { key: 'view_from_windows', label: '–í–∏–¥ –∏–∑ –æ–∫–æ–Ω' }, { key: 'parking', label: '–ü–∞—Ä–∫–æ–≤–∫–∞' }, { key: 'metro_distance', label: '–ú–µ—Ç—Ä–æ' }, { key: 'year_built', label: '–ì–æ–¥ –ø–æ—Å—Ç—Ä–æ–π–∫–∏' }, { key: 'building_type', label: '–¢–∏–ø –¥–æ–º–∞' }, { key: 'decoration', label: '–û—Ç–¥–µ–ª–∫–∞' }, { key: 'deal_type', label: '–¢–∏–ø —Å–¥–µ–ª–∫–∏' }, { key: 'mortgage_available', label: '–ò–ø–æ—Ç–µ–∫–∞' } ]; rows.forEach(rowData => { const row = createTableRow(rowData.label); comparisonData.forEach((property, index) => { const cell = row.children[index + 1]; let value = property[rowData.key] || '-'; if (rowData.formatter && property[rowData.key]) { value = rowData.formatter(property[rowData.key]); } cell.innerHTML = `${value}`; }); tbody.appendChild(row); }); // Update last updated time document.getElementById('last-updated').textContent = new Date().toLocaleTimeString('ru-RU'); } function createTableRow(label) { const row = document.createElement('tr'); row.innerHTML = ` ${label} `; return row; } function updateStats() { const countEl = document.getElementById('comparison-count'); const avgPriceEl = document.getElementById('average-price'); const avgAreaEl = document.getElementById('average-area'); if (currentTab === 'properties') { countEl.textContent = comparisonData.length; } else { countEl.textContent = complexComparisonData.length; } if (comparisonData.length > 0) { // Calculate average price const prices = comparisonData.filter(p => p.property_price).map(p => p.property_price); const avgPrice = prices.length > 0 ? prices.reduce((a, b) => a + b, 0) / prices.length : 0; avgPriceEl.textContent = avgPrice > 0 ? formatPrice(avgPrice) : '-'; // Calculate average area const areas = comparisonData.filter(p => p.property_size).map(p => p.property_size); const avgArea = areas.length > 0 ? areas.reduce((a, b) => a + b, 0) / areas.length : 0; avgAreaEl.textContent = avgArea > 0 ? `${Math.round(avgArea)} –º¬≤` : '-'; } else { avgPriceEl.textContent = '-'; avgAreaEl.textContent = '-'; } // Update navigation counter updateComparisonCounter(); } function formatPrice(price) { return new Intl.NumberFormat('ru-RU', { style: 'currency', currency: 'RUB', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(price); } // –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è - –æ–±—ä–µ–∫—Ç—ã –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ /properties –∏ /residential-complexes function loadFavoriteProperties() { console.log('‚ö†Ô∏è loadFavoriteProperties() deprecated - use /properties page instead'); alert('–î–æ–±–∞–≤–ª—è–π—Ç–µ –æ–±—ä–µ–∫—Ç—ã –∫ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –ñ–ö'); } function showFavoritePropertiesModal(properties) { // Implementation for showing modal with favorite properties console.log('Showing favorite properties:', properties); } function sendComparisonToClient() { if (comparisonData.length === 0) { alert('–î–æ–±–∞–≤—å—Ç–µ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è'); return; } // Implementation for sending comparison to client console.log('Sending comparison to client:', comparisonData); alert('–§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–ª–∏–µ–Ω—Ç—É –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞'); } function saveComparisonTemplate() { if (comparisonData.length === 0) { alert('–î–æ–±–∞–≤—å—Ç–µ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è'); return; } const templateName = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–∞:'); if (templateName) { // Implementation for saving as template console.log('Saving as template:', templateName, comparisonData); alert('–®–∞–±–ª–æ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω'); } } function exportComparison() { if (comparisonData.length === 0) { alert('–î–æ–±–∞–≤—å—Ç–µ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è'); return; } // Implementation for PDF export console.log('Exporting comparison:', comparisonData); alert('–≠–∫—Å–ø–æ—Ä—Ç –≤ PDF –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω'); } function updateComparisonCounter() { // Update comparison counter in navigation const totalItems = comparisonData.length + complexComparisonData.length; const counterElement = document.getElementById('comparison-count'); if (counterElement) { counterElement.textContent = totalItems; console.log('üî¢ Updated comparison counter to:', totalItems); } // External JavaScript file handles all initialization